{"ast":null,"code":"import Web3 from \"web3\";\nimport LipToken from \"../../contracts/LipToken.json\";\nimport { fetchData } from \"../data/dataActions\";\n\nconst connectRequest = () => {\n  return {\n    type: \"CONNECTION_REQUEST\"\n  };\n};\n\nconst connectSuccess = payload => {\n  return {\n    type: \"CONNECTION_SUCCESS\",\n    payload: payload\n  };\n};\n\nconst connectFailed = payload => {\n  return {\n    type: \"CONNECTION_FAILED\",\n    payload: payload\n  };\n};\n\nconst updateAccountRequest = payload => {\n  return {\n    type: \"UPDATE_ACCOUNT\",\n    payload: payload\n  };\n};\n\nexport const connect = () => {\n  return async dispatch => {\n    dispatch(connectRequest());\n\n    if (window.ethereum) {\n      let web3 = new Web3(window.ethereum);\n\n      try {\n        const accounts = await window.ethereum.request({\n          method: \"eth_accounts\"\n        });\n        console.log(accounts);\n        const networkId = await window.ethereum.request({\n          method: \"net_version\"\n        });\n        console.log(networkId); // ID de la Blockchain de despliegue\n        // Ganache -> 5777\n        // BSC Testnet -> 97\n        // MATIC/Polygon -> 80001\n        // Rinkeby -> 4\n\n        if (networkId == 5777) {\n          const networkData = LipToken.networks[networkId];\n          const abi = LipToken.abi;\n          const address = networkData.address;\n          const lipToken = new web3.eth.Contract(abi, address);\n          console.log(lipToken);\n          dispatch(connectSuccess({\n            account: accounts[0],\n            lipToken: lipToken,\n            web3: web3\n          }));\n          window.ethereum.on(\"accountsChanged\", accounts => {\n            dispatch(updateAccount(accounts[0]));\n          });\n          window.ethereum.on(\"chainChanged\", () => {\n            window.location.reload();\n          });\n        } else {\n          dispatch(connectFailed(\"¡El Smart Contract no se ha desplegado en la red!\"));\n        }\n      } catch (err) {\n        dispatch(connectFailed(\"¡Algo ha salido mal!\"));\n      }\n    } else {\n      dispatch(connectFailed(\"¡Instala Metamask!\"));\n    }\n  };\n};\nexport const updateAccount = account => {\n  return async dispatch => {\n    dispatch(updateAccountRequest({\n      account: account\n    }));\n    dispatch(fetchData(account));\n  };\n};","map":{"version":3,"sources":["C:/Users/digit/OneDrive/Escritorio/nft/src/redux/blockchain/blockchainActions.js"],"names":["Web3","LipToken","fetchData","connectRequest","type","connectSuccess","payload","connectFailed","updateAccountRequest","connect","dispatch","window","ethereum","web3","accounts","request","method","console","log","networkId","networkData","networks","abi","address","lipToken","eth","Contract","account","on","updateAccount","location","reload","err"],"mappings":"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","sourcesContent":["import Web3 from \"web3\"\nimport LipToken from \"../../contracts/LipToken.json\"\nimport { fetchData } from \"../data/dataActions\"\n\nconst connectRequest = () => {\n    return {\n        type: \"CONNECTION_REQUEST\",\n    };\n};\n\nconst connectSuccess = (payload) => {\n    return {\n        type: \"CONNECTION_SUCCESS\",\n        payload: payload,\n    };\n};\n\nconst connectFailed = (payload) => {\n    return {\n        type: \"CONNECTION_FAILED\",\n        payload: payload,\n    };\n};\n\nconst updateAccountRequest = (payload) => {\n    return {\n        type: \"UPDATE_ACCOUNT\",\n        payload: payload,\n    };\n};\n\nexport const connect = () => {\n    return async (dispatch) => {\n        dispatch(connectRequest());\n        if(window.ethereum) {\n            let web3 = new Web3(window.ethereum);\n            try {\n                const accounts = await window.ethereum.request({method: \"eth_accounts\",});\n                console.log(accounts);\n                const networkId = await window.ethereum.request({method: \"net_version\", });\n                console.log(networkId);\n                // ID de la Blockchain de despliegue\n                // Ganache -> 5777\n                // BSC Testnet -> 97\n                // MATIC/Polygon -> 80001\n                // Rinkeby -> 4\n                if (networkId == 5777) {\n                    const networkData = LipToken.networks[networkId];\n                    const abi = LipToken.abi;\n                    const address = networkData.address;\n                    const lipToken = new web3.eth.Contract(abi, address);\n                    console.log(lipToken);\n                    dispatch(\n                        connectSuccess({\n                            account: accounts[0],\n                            lipToken: lipToken,\n                            web3: web3,\n                        })\n                    );\n\n                    window.ethereum.on(\"accountsChanged\", (accounts) => {\n                        dispatch(updateAccount(accounts[0]));\n                    });\n\n                    window.ethereum.on(\"chainChanged\", () => {\n                        window.location.reload();\n                    });\n                } else {\n                    dispatch(connectFailed(\"¡El Smart Contract no se ha desplegado en la red!\"));\n                    } \n                } catch(err) {\n                    dispatch(connectFailed(\"¡Algo ha salido mal!\"))\n                }\n            } else {\n                dispatch(connectFailed(\"¡Instala Metamask!\"))\n            }\n        };\n    };\n\n    export const updateAccount = (account) => {\n        return async (dispatch) => {\n            dispatch(updateAccountRequest({account: account}));\n            dispatch(fetchData(account));\n        };\n    };\n"]},"metadata":{},"sourceType":"module"}